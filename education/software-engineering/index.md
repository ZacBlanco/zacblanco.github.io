---
layout: page
title: Software Engineering
permalink: /education/software-engineering/
keywords: 14:332:452, rutgers, software, engineering, marsic, ivan, SE, git, version, control, team
description: A page full of notes and useful links for succeeding in Software Engineering at Rutgers University.
---

These notes are for a version of the class taught by professor Ivan Marsic in the spring of 2017.

[You can find the course materials here](http://ece.rutgers.edu/~marsic/Teaching/SE)

## Lecture 1 - 1/17/17 

Software engineering is the bridge from customer requirements to implementation.

**First law of software engineering**: Software engineers are willing to learn the problem domain. (or a problem cannot be solved without first gaining an understanding of it.)

Software engineers need to take customer problems or requirements and be able to analyze those requirements and turn that into a robust implementation. Good engineers will be able to combine their understanding of the requirements that a customer is asking for and use that and their background knowledge to come up with great implementations. They should be able to argue why their solution is the *best*.

There are three different types of people when creating software projects.

- **Customer**
  - Requires a computer system to achieve some business goals by a user interactions or interaction with the environment in a specified manner.
- **Software Engineer**
  - Required to understand how the system-to-be needs to interact with the user or the environment so that the customer's requimrent is met and *design* the software-to-be.
- **Programmer**
  - Goal is to implement the software-to-be which is designed by the sotware engineer.

Many times the software engineer and programmer's tasks will interweave with one another.

**Software Engineering Blueprints** - UML diagrams are like blueprints for a program. They allow us to visually represent our software

**Second Law of Software Engineering** - Software should be written for people first.

- Computers run software, but hardware quickly becomes outdated
- Useful & good software lives long.
- To nurture software people; must be able to understand it.



